<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoVision AI Futures Trading - Levier 20√ó</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <!-- SONS D'ALARME -->
    <audio id="win-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>
    <audio id="loss-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-warning-alarm-buzzer-957.mp3" type="audio/mpeg">
    </audio>
    <audio id="limit-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3" type="audio/mpeg">
    </audio>
    <style>
        /* ================= VARIABLES & RESET ================= */
        :root {
            --primary: #00d4ff;
            --primary-dark: #0099ff;
            --secondary: #00ff88;
            --danger: #ff416c;
            --warning: #ff9900;
            --futures: #9d4edd;
            --background: #0a0e17;
            --card-bg: #111827;
            --card-border: #1e2a3a;
            --text: #ffffff;
            --text-muted: #8a9bb0;
            --success: #00ff88;
            --gradient-primary: linear-gradient(135deg, #00d4ff, #0099ff);
            --gradient-success: linear-gradient(135deg, #00ff88, #00cc66);
            --gradient-danger: linear-gradient(135deg, #ff416c, #ff4b2b);
            --gradient-warning: linear-gradient(135deg, #ff9900, #ff5500);
            --gradient-futures: linear-gradient(135deg, #9d4edd, #7b2cbf);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
            padding: 10px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
        }

        /* ================= HEADER & NAV ================= */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--card-border);
            flex-wrap: wrap;
            gap: 15px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 24px;
            font-weight: 800;
            color: var(--futures);
        }

        .logo i {
            font-size: 28px;
        }

        .lever-badge {
            background: var(--warning);
            color: #000;
            padding: 5px 12px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 14px;
            margin-left: 8px;
            box-shadow: 0 4px 10px rgba(255, 153, 0, 0.3);
        }

        .futures-badge {
            background: var(--gradient-futures);
            color: white;
            padding: 5px 12px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 12px;
            margin-left: 8px;
        }

        .menu {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .menu a {
            color: var(--text-muted);
            text-decoration: none;
            padding: 10px 18px;
            border-radius: 10px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            border: 1px solid transparent;
            font-size: 14px;
        }

        .menu a.active,
        .menu a:hover {
            background: rgba(30, 42, 58, 0.6);
            border-color: var(--futures);
            color: var(--futures);
            box-shadow: 0 5px 15px rgba(157, 78, 221, 0.2);
        }

        /* ================= DASHBOARD GRID ================= */
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 22px;
            border: 1px solid var(--card-border);
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .card:hover {
            border-color: var(--futures);
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(157, 78, 221, 0.15);
        }

        .card h2 {
            color: var(--futures);
            margin-bottom: 20px;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(30, 42, 58, 0.5);
        }

        /* ================= BALANCE & STATUS ================= */
        .balance {
            font-size: 42px;
            font-weight: 900;
            color: var(--secondary);
            text-align: center;
            margin: 20px 0;
            text-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), transparent);
            padding: 18px;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .status {
            padding: 16px;
            border-radius: 12px;
            margin: 18px 0;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
        }

        .status-online {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--secondary);
            color: var(--secondary);
        }

        .status-offline {
            background: rgba(255, 65, 108, 0.1);
            border: 1px solid var(--danger);
            color: var(--danger);
        }

        /* ================= BOUTONS ================= */
        .btn {
            background: var(--gradient-futures);
            color: white;
            border: none;
            padding: 15px 28px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(157, 78, 221, 0.4);
        }

        .btn-green {
            background: var(--gradient-success);
        }

        .btn-red {
            background: var(--gradient-danger);
        }

        .btn-long {
            background: linear-gradient(135deg, #00ff88, #00cc66);
        }

        .btn-short {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
        }

        /* ================= FORMULAIRES ================= */
        .input-group {
            margin: 18px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-muted);
            font-weight: 600;
            font-size: 14px;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 15px;
            background: #1a2234;
            border: 1px solid #2a3a5a;
            border-radius: 10px;
            color: white;
            font-size: 15px;
            transition: all 0.3s;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--futures);
            box-shadow: 0 0 0 3px rgba(157, 78, 221, 0.2);
        }

        /* ================= BADGES VOLATILIT√â ================= */
        .volatility-badge {
            color: white;
            padding: 5px 12px;
            border-radius: 30px;
            font-size: 11px;
            margin-left: 6px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .low-vol {
            background: linear-gradient(135deg, #00cc66, #00994d);
        }

        .medium-vol {
            background: linear-gradient(135deg, #ff9900, #cc7700);
        }

        .high-vol {
            background: linear-gradient(135deg, #ff3366, #cc0044);
        }

        /* ================= NOTES S√âCURIT√â ================= */
        .security-note {
            background: rgba(157, 78, 221, 0.1);
            border: 1px solid #9d4edd;
            color: #9d4edd;
            padding: 16px;
            border-radius: 12px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 12px;
            line-height: 1.6;
            font-size: 14px;
        }

        .security-note i {
            font-size: 20px;
        }

        .security-note strong {
            color: #c77dff;
        }

        /* ================= LOGS & HISTORIQUE ================= */
        .trade-log {
            background: #0d1422;
            border-radius: 12px;
            padding: 18px;
            margin-top: 20px;
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid var(--card-border);
        }

        .log-entry {
            padding: 12px;
            border-bottom: 1px solid rgba(30, 42, 58, 0.5);
            font-family: 'Courier New', monospace;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.3s;
        }

        .log-entry:hover {
            background: rgba(30, 42, 58, 0.3);
        }

        .log-success {
            color: var(--secondary);
            border-left: 4px solid var(--secondary);
            padding-left: 8px;
        }

        .log-error {
            color: var(--danger);
            border-left: 4px solid var(--danger);
            padding-left: 8px;
        }

        .log-info {
            color: var(--futures);
            border-left: 4px solid var(--futures);
            padding-left: 8px;
        }

        /* ================= POSITIONS ACTIVES ================= */
        .position-card {
            background: linear-gradient(135deg, rgba(157, 78, 221, 0.1), rgba(0, 212, 255, 0.05));
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid rgba(157, 78, 221, 0.3);
        }

        .position-long {
            border-left: 4px solid #00ff88;
        }

        .position-short {
            border-left: 4px solid #ff416c;
        }

        /* ================= UTILITAIRES ================= */
        .section {
            animation: fadeIn 0.5s ease;
        }

        .hidden {
            display: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ================= RESPONSIVE ================= */
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .menu {
                width: 100%;
                justify-content: center;
            }
            
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .balance {
                font-size: 36px;
            }
            
            .card {
                padding: 18px;
            }
            
            .btn {
                padding: 14px 20px;
                font-size: 15px;
            }
        }

        /* ================= SCROLLBAR ================= */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0d1422;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--futures);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #7b2cbf;
        }

        /* ================= NOUVEAU : CARTE IA AUTO ================= */
        .ai-selection-card {
            background: linear-gradient(135deg, rgba(157, 78, 221, 0.15), rgba(0, 212, 255, 0.08));
            border: 2px dashed #9d4edd;
        }

        .ai-selection-status {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
            text-align: center;
        }

        .ai-searching {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid #ffc107;
            color: #ffc107;
        }

        .ai-found {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .pair-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            padding: 10px;
            background: rgba(30, 42, 58, 0.3);
            border-radius: 8px;
        }

        .pair-item {
            padding: 8px;
            margin: 4px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
        }

        .pair-item.best {
            background: rgba(0, 255, 136, 0.15);
            border-left: 3px solid #00ff88;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-rocket"></i>
                <span>CryptoVision AI</span>
                <span class="lever-badge">20√ó</span>
                <span class="futures-badge">FUTURES</span>
            </div>
            <div class="menu">
                <a href="#" class="active" onclick="showSection('dashboard')"><i class="fas fa-chart-line"></i> Trading</a>
                <a href="#" onclick="showSection('positions')"><i class="fas fa-layer-group"></i> Positions</a>
                <a href="#" onclick="showSection('settings')"><i class="fas fa-cog"></i> API Futures</a>
                <a href="#" onclick="showSection('history')"><i class="fas fa-history"></i> Historique</a>
            </div>
        </header>
        
        <!-- SECTION DASHBOARD -->
        <div id="dashboard-section" class="section">
            <div class="dashboard">
                <div class="card">
                    <h2><i class="fas fa-wallet"></i> Compte Futures</h2>
                    <div class="balance" id="balance">0.00 USDT</div>
                    <div class="status" id="connection-status">
                        <i class="fas fa-plug"></i> Lbank Futures: <span id="status-text">D√©connect√©</span>
                    </div>
                    <button class="btn" onclick="connectToLbankFutures()"><i class="fas fa-link"></i> Connecter API Futures</button>
                    <button class="btn btn-green" onclick="testApiConnection()"><i class="fas fa-vial"></i> Tester Connexion API</button>
                </div>
                
                <!-- NOUVELLE CARTE : IA AUTO-SELECTION -->
                <div class="card ai-selection-card">
                    <h2><i class="fas fa-robot"></i> IA Auto-S√©lection</h2>
                    <div class="ai-selection-status" id="ai-status">
                        <i class="fas fa-search"></i> Pr√™te √† analyser les paires
                    </div>
                    
                    <div class="pair-list" id="pair-analysis-list">
                        <!-- Liste des paires analys√©es -->
                    </div>
                    
                    <div class="input-group">
                        <label>Mode Trading IA</label>
                        <select id="trading-mode">
                            <option value="auto">Auto - IA choisit la meilleure paire</option>
                            <option value="manual">Manuel - Je choisis la paire</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label>Seuil de confiance IA (%)</label>
                        <input type="number" id="ai-confidence" value="75" min="50" max="95">
                        <small style="color: #8a9bb0;">Confiance minimum pour trader</small>
                    </div>
                    
                    <div id="manual-pair-section">
                        <div class="input-group">
                            <label>Contrat Futures (manuel)</label>
                            <select id="trading-pair">
                                <option value="BTC_USDT-PERP">BTC/USDT-PERP <span class="volatility-badge low-vol">Faible Vol</span></option>
                                <option value="ETH_USDT-PERP">ETH/USDT-PERP <span class="volatility-badge low-vol">Faible Vol</span></option>
                                <option value="BNB_USDT-PERP">BNB/USDT-PERP <span class="volatility-badge medium-vol">Moyenne Vol</span></option>
                                <option value="SOL_USDT-PERP">SOL/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="XRP_USDT-PERP">XRP/USDT-PERP <span class="volatility-badge medium-vol">Moyenne Vol</span></option>
                                <option value="ADA_USDT-PERP">ADA/USDT-PERP <span class="volatility-badge medium-vol">Moyenne Vol</span></option>
                                <option value="DOGE_USDT-PERP">DOGE/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="DOT_USDT-PERP">DOT/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="MATIC_USDT-PERP">MATIC/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="AVAX_USDT-PERP">AVAX/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="LINK_USDT-PERP">LINK/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="UNI_USDT-PERP">UNI/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="AAVE_USDT-PERP">AAVE/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="SHIB_USDT-PERP">SHIB/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="PEPE_USDT-PERP">PEPE/USDT-PERP <span class="volatility-badge high-vol">Haute Vol</span></option>
                                <option value="GIGGLE_USDT-PERP">GIGGLE_USDT-PERP <span class="volatility-badge high-vol">TR√àS HAUTE VOL</span></option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="security-note">
                        <i class="fas fa-brain"></i> 
                        <strong>IA EXPERTE AUTO-SELECTION</strong> - Analyse toutes les paires et choisit la meilleure opportunit√©
                    </div>
                </div>
                
                <div class="card">
                    <h2><i class="fas fa-bolt"></i> Contr√¥le Futures</h2>
                    <div class="input-group">
                        <label>Position size (USDT) <span style="color: #ff9900; font-size: 12px;">√ó20</span></label>
                        <input type="number" id="trade-amount" value="100" min="2">
                        <small style="color: #8a9bb0; display: block; margin-top: 5px;">Exposition r√©elle: <span id="exposure">2,000 USDT</span></small>
                    </div>
                    
                    <div class="security-note">
                        <i class="fas fa-shield-alt"></i> 
                        <strong>CONTRAT FUTURES PERP√âTUEL</strong> - Marge isol√©e obligatoire | Levier 20√ó fixe | Funding rates inclus
                    </div>
                    
                    <div class="security-note" style="background: rgba(255, 65, 108, 0.1); border-color: #ff416c; color: #ff416c;">
                        <i class="fas fa-chart-line"></i> 
                        <strong>RATIO RISQUE/R√âCOMPENSE 1:3</strong> - Stop Loss: 5% | Take Profit: 15%
                    </div>
                    
                    <button class="btn btn-green" onclick="startFuturesTrading()"><i class="fas fa-play"></i> D√©marrer Trading Futures</button>
                    <button class="btn btn-red" onclick="stopTrading()"><i class="fas fa-stop"></i> Arr√™ter Trading</button>
                </div>
                
                <div class="card">
                    <h2><i class="fas fa-chart-line"></i> Stats du Cycle</h2>
                    <div id="daily-stats">
                        <p style="color: #8a9bb0; text-align: center; padding: 20px;">
                            <i class="fas fa-sync"></i> Cycle non d√©marr√©
                        </p>
                    </div>
                </div>
                
                <div class="card">
                    <h2><i class="fas fa-list-alt"></i> Journal Futures</h2>
                    <div class="trade-log" id="trade-log">
                        <div class="log-entry log-info">Syst√®me Futures pr√™t. Connectez votre API Lbank.</div>
                        <div class="log-entry log-info">IA experte en trading futures avec levier 20√ó obligatoire</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- SECTION POSITIONS -->
        <div id="positions-section" class="section hidden">
            <div class="card">
                <h2><i class="fas fa-layer-group"></i> Positions Actives Futures</h2>
                <div id="positions-container">
                    <p style="color: #8a9bb0; text-align: center; padding: 20px;">Aucune position active</p>
                </div>
                <div style="margin-top: 20px; display: flex; gap: 10px;">
                    <button class="btn btn-long" onclick="closeAllPositions('LONG')"><i class="fas fa-arrow-up"></i> Fermer tous LONG</button>
                    <button class="btn btn-short" onclick="closeAllPositions('SHORT')"><i class="fas fa-arrow-down"></i> Fermer tous SHORT</button>
                </div>
            </div>
            
            <div class="card">
                <h2><i class="fas fa-calculator"></i> Calculateur Marge</h2>
                <div class="input-group">
                    <label>Montant position (USDT)</label>
                    <input type="number" id="margin-calc-amount" value="100" min="2">
                </div>
                <div class="input-group">
                    <label>Levier</label>
                    <input type="number" id="margin-calc-leverage" value="20" min="1" max="100" disabled>
                </div>
                <div style="background: rgba(157, 78, 221, 0.1); padding: 15px; border-radius: 10px; margin: 20px 0;">
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #8a9bb0;">Marge requise:</span>
                        <span style="color: #9d4edd; font-weight: bold;" id="margin-required">5.00 USDT</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                        <span style="color: #8a9bb0;">Exposition r√©elle:</span>
                        <span style="color: #00ff88; font-weight: bold;" id="real-exposure">2,000 USDT</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                        <span style="color: #8a9bb0;">Liquidation √†:</span>
                        <span style="color: #ff416c; font-weight: bold;" id="liquidation-price">4.75%</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- SECTION PARAM√àTRES -->
        <div id="settings-section" class="section hidden">
            <div class="card">
                <h2><i class="fas fa-key"></i> API Futures Lbank</h2>
                <div class="security-note">
                    <i class="fas fa-exclamation-triangle"></i> 
                    <strong>API FUTURES REQUISE</strong> - Utilisez les cl√©s API du compte Futures, pas du compte Spot
                </div>
                <div class="input-group">
                    <label>Cl√© API Futures Lbank</label>
                    <input type="password" id="api-key" placeholder="Cl√© API du compte Futures">
                </div>
                <div class="input-group">
                    <label>Cl√© Secr√®te Futures Lbank</label>
                    <input type="password" id="api-secret" placeholder="Cl√© secr√®te du compte Futures">
                </div>
                <div class="input-group">
                    <label>Mode Marge Futures</label>
                    <select id="margin-mode">
                        <option value="isolated" selected>Marge Isol√©e (OBLIGATOIRE)</option>
                        <option value="cross" disabled>Marge Crois√©e (d√©sactiv√©)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>PIN de s√©curit√©</label>
                    <input type="password" id="pin-code" value="2025" maxlength="4">
                </div>
                <div class="security-note">
                    <i class="fas fa-lock"></i> 
                    <strong>Vos cl√©s sont chiffr√©es localement</strong> - Stock√©es uniquement sur cet appareil
                </div>
                <button class="btn" onclick="saveApiConfig()"><i class="fas fa-save"></i> Enregistrer Configuration Futures</button>
                <button class="btn btn-red" onclick="clearAllData()"><i class="fas fa-trash"></i> Effacer Toutes les Donn√©es</button>
            </div>
            
            <div class="card">
                <h2><i class="fas fa-sliders-h"></i> Param√®tres Futures</h2>
                <div class="input-group">
                    <label>Stop-loss (%) <span style="color: #ff416c; font-size: 12px;">Futures</span></label>
                    <input type="number" id="stop-loss" value="5" min="1" max="10">
                    <small style="color: #8a9bb0;">Ratio 1:3 - Perte max: 5% par trade</small>
                </div>
                <div class="input-group">
                    <label>Take-profit (%) <span style="color: #00ff88; font-size: 12px;">Futures</span></label>
                    <input type="number" id="take-profit" value="15" min="3" max="20">
                    <small style="color: #8a9bb0;">Ratio 1:3 - Gain cible: 15% par trade</small>
                </div>
                <div class="input-group">
                    <label>Levier Futures</label>
                    <input type="number" id="leverage" value="20" min="1" max="100" disabled>
                    <small style="color: #ff9900; display: block; margin-top: 5px;">Levier 20√ó FIXE pour tous les contrats</small>
                </div>
                <div class="input-group">
                    <label>Funding Rate Alert (%)</label>
                    <input type="number" id="funding-alert" value="0.01" min="0.001" max="0.1" step="0.001">
                    <small style="color: #8a9bb0;">Alerte si funding rate d√©passe cette valeur</small>
                </div>
                <button class="btn" onclick="saveTradingConfig()"><i class="fas fa-save"></i> Sauvegarder Param√®tres Futures</button>
            </div>
        </div>
        
        <!-- SECTION HISTORIQUE -->
        <div id="history-section" class="section hidden">
            <div class="card">
                <h2><i class="fas fa-history"></i> Historique Futures</h2>
                <div id="history-container">
                    <p style="color: #8a9bb0; text-align: center; padding: 20px;">Aucun trade historique</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================= CONFIGURATION FUTURES =================
        const FUTURES_CONFIG = {
            LEVERAGE: 20,
            MARGIN_MODE: 'isolated',
            EXCHANGE: 'Lbank Futures',
            API_VERSION: 'v2',
            CONTRACT_TYPE: 'PERPETUAL',
            SETTLEMENT: 'USDT',
            VERSION: '5.0.0',
            SECURITY_LEVEL: 'ULTRA_HIGH'
        };

        // ================= LIMITES TRADING FUTURES =================
        const TRADING_LIMITS = {
            MIN_DAILY_TRADES: 6,
            MAX_DAILY_TRADES: 10,
            MAX_DAILY_LOSSES: 3,
            MIN_POSITION_SIZE: 2,
            CYCLE_HOURS: 24,
            MAX_EXPOSURE: 100000,
            MIN_MARGIN_RATIO: 0.05,
            RISK_REWARD_RATIO: 3.0
        };

        // ================= PAIRES FUTURES DISPONIBLES =================
        const FUTURES_PAIRS = {
            'BTC_USDT-PERP': { symbol: 'BTCUSDT', tickSize: 0.1, minQty: 0.001, volatility: 'LOW', lastAnalysis: null },
            'ETH_USDT-PERP': { symbol: 'ETHUSDT', tickSize: 0.01, minQty: 0.01, volatility: 'LOW', lastAnalysis: null },
            'BNB_USDT-PERP': { symbol: 'BNBUSDT', tickSize: 0.001, minQty: 0.1, volatility: 'MEDIUM', lastAnalysis: null },
            'SOL_USDT-PERP': { symbol: 'SOLUSDT', tickSize: 0.001, minQty: 0.1, volatility: 'HIGH', lastAnalysis: null },
            'XRP_USDT-PERP': { symbol: 'XRPUSDT', tickSize: 0.0001, minQty: 1, volatility: 'MEDIUM', lastAnalysis: null },
            'ADA_USDT-PERP': { symbol: 'ADAUSDT', tickSize: 0.0001, minQty: 1, volatility: 'MEDIUM', lastAnalysis: null },
            'DOGE_USDT-PERP': { symbol: 'DOGEUSDT', tickSize: 0.0001, minQty: 10, volatility: 'HIGH', lastAnalysis: null },
            'DOT_USDT-PERP': { symbol: 'DOTUSDT', tickSize: 0.001, minQty: 0.1, volatility: 'HIGH', lastAnalysis: null },
            'MATIC_USDT-PERP': { symbol: 'MATICUSDT', tickSize: 0.0001, minQty: 1, volatility: 'HIGH', lastAnalysis: null },
            'AVAX_USDT-PERP': { symbol: 'AVAXUSDT', tickSize: 0.001, minQty: 0.1, volatility: 'HIGH', lastAnalysis: null },
            'LINK_USDT-PERP': { symbol: 'LINKUSDT', tickSize: 0.001, minQty: 0.1, volatility: 'HIGH', lastAnalysis: null },
            'UNI_USDT-PERP': { symbol: 'UNIUSDT', tickSize: 0.001, minQty: 0.1, volatility: 'HIGH', lastAnalysis: null },
            'AAVE_USDT-PERP': { symbol: 'AAVEUSDT', tickSize: 0.01, minQty: 0.01, volatility: 'HIGH', lastAnalysis: null },
            'SHIB_USDT-PERP': { symbol: 'SHIBUSDT', tickSize: 0.00000001, minQty: 10000, volatility: 'HIGH', lastAnalysis: null },
            'PEPE_USDT-PERP': { symbol: 'PEPEUSDT', tickSize: 0.00000001, minQty: 10000, volatility: 'HIGH', lastAnalysis: null },
            'GIGGLE_USDT-PERP': { symbol: 'GIGGLEUSDT', tickSize: 0.0001, minQty: 10, volatility: 'EXTREME', lastAnalysis: null }
        };

        // ================= CLASSE IA EXPERTE FUTURES AVEC AUTO-SELECTION =================
        class FuturesTradingAI {
            constructor() {
                this.LEVERAGE = 20;
                this.MARGIN_MODE = 'isolated';
                this.STOP_LOSS = 5;
                this.TAKE_PROFIT = 15;
                
                this.futuresKnowledge = {
                    longShort: 'expert',
                    leverageManagement: 'expert',
                    marginManagement: 'expert',
                    positionSizing: 'expert',
                    riskManagement: 'expert',
                    fundingRates: 'advanced',
                    liquidation: 'advanced',
                    hedging: 'intermediate',
                    volatility: 'expert',
                    pairSelection: 'expert'
                };
                
                this.analysisTime = {
                    LOW: 1200,
                    MEDIUM: 2000,
                    HIGH: 3000,
                    EXTREME: 4500
                };

                this.analyzedPairs = [];
            }

            async analyzeAllPairs() {
                this.analyzedPairs = [];
                const analysisPromises = [];
                
                logMessage('üîç IA analyse toutes les paires disponibles...', 'info');
                updateAIStatus('searching', 'Analyse en cours...');
                
                for (const pair in FUTURES_PAIRS) {
                    analysisPromises.push(this.analyzeSinglePair(pair));
                }
                
                const results = await Promise.all(analysisPromises);
                const validResults = results.filter(r => r !== null);
                validResults.sort((a, b) => b.decision.confidence - a.decision.confidence);
                
                this.analyzedPairs = validResults;
                updatePairAnalysisList(validResults);
                
                if (validResults.length > 0) {
                    const bestPair = validResults[0];
                    updateAIStatus('found', `Meilleure paire: ${bestPair.pair} (${(bestPair.decision.confidence * 100).toFixed(1)}%)`);
                    
                    logMessage(`üéØ IA a trouv√© ${validResults.length} opportunit√©s`, 'success');
                    logMessage(`üèÜ Meilleure: ${bestPair.pair} - Confiance: ${(bestPair.decision.confidence * 100).toFixed(1)}%`, 'success');
                    
                    return bestPair;
                } else {
                    updateAIStatus('none', 'Aucune opportunit√© trouv√©e');
                    logMessage('‚ö†Ô∏è IA n\'a trouv√© aucune opportunit√© valide', 'warning');
                    return null;
                }
            }

            async analyzeSinglePair(pair) {
                try {
                    const volatility = this.getVolatilityLevel(pair);
                    const analysisTime = this.analysisTime[volatility];
                    await this.simulateAnalysis(analysisTime);
                    
                    const analysisDepth = {
                        LOW: 2,
                        MEDIUM: 3,
                        HIGH: 4,
                        EXTREME: 5
                    }[volatility];

                    const analysis = this.deepFuturesAnalysis(pair, analysisDepth);
                    
                    analysis.decision.stopLoss = this.STOP_LOSS;
                    analysis.decision.takeProfit = this.TAKE_PROFIT;
                    analysis.decision.riskRewardRatio = TRADING_LIMITS.RISK_REWARD_RATIO;
                    
                    return {
                        pair: pair,
                        symbol: FUTURES_PAIRS[pair].symbol,
                        volatility: volatility,
                        analysisTime: analysisTime,
                        ...analysis
                    };
                } catch (error) {
                    console.error(`Erreur analyse ${pair}:`, error);
                    return null;
                }
            }

            getVolatilityLevel(pair) {
                const pairInfo = FUTURES_PAIRS[pair];
                return pairInfo ? pairInfo.volatility : 'MEDIUM';
            }

            simulateAnalysis(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            deepFuturesAnalysis(pair, depth) {
                const analyses = [];
                
                for (let i = 1; i <= depth; i++) {
                    analyses.push({
                        level: i,
                        futuresIndicators: this.generateFuturesIndicators(pair, i),
                        confidence: Math.min(0.65 + (i * 0.08), 0.92),
                        riskAssessment: this.assessFuturesRisk(pair, i),
                        marginSafety: this.calculateMarginSafety(i),
                        liquidationRisk: this.calculateLiquidationRisk(pair, i)
                    });
                }

                const finalDecision = this.makeFuturesDecision(analyses, pair);
                finalDecision.leverage = this.LEVERAGE;
                finalDecision.marginMode = this.MARGIN_MODE;
                finalDecision.positionType = 'PERPETUAL';
                finalDecision.stopLoss = this.STOP_LOSS;
                finalDecision.takeProfit = this.TAKE_PROFIT;
                finalDecision.riskRewardRatio = TRADING_LIMITS.RISK_REWARD_RATIO;
                
                return {
                    decision: finalDecision,
                    analysisDepth: depth,
                    volatility: this.getVolatilityLevel(pair),
                    timestamp: new Date().toISOString(),
                    futuresSpecific: {
                        fundingRateImpact: this.estimateFundingRateImpact(pair),
                        liquidationPrice: this.calculateLiquidationPrice(pair, finalDecision.action),
                        marginRatio: TRADING_LIMITS.MIN_MARGIN_RATIO,
                        maxDrawdown: this.calculateMaxDrawdown(finalDecision.action)
                    }
                };
            }

            generateFuturesIndicators(pair, level) {
                const baseIndicators = ['Funding Rate', 'Open Interest', 'Liquidation Levels', 'Basis', 'Volume Profile'];
                const advancedIndicators = ['Liquidations Heatmap', 'Margin Ratio Trend', 'Position Skew', 'Delta Neutral', 'Gamma Exposure'];
                const expertIndicators = ['Perpetual Arbitrage', 'Cross-Market Spread', 'Hedging Efficiency', 'Risk Reversal', 'Volatility Smile'];
                
                let indicators = [...baseIndicators];
                if (level >= 2) indicators.push('Mark Price', 'Index Price', 'Premium/Discount');
                if (level >= 3) indicators.push(...advancedIndicators.slice(0, 3));
                if (level >= 4) indicators.push(...advancedIndicators.slice(3));
                if (level >= 5) indicators.push(...expertIndicators);
                
                return indicators;
            }

            assessFuturesRisk(pair, level) {
                const volatility = this.getVolatilityLevel(pair);
                const riskBase = {
                    LOW: 0.25,
                    MEDIUM: 0.45,
                    HIGH: 0.65,
                    EXTREME: 0.85
                }[volatility];
                const riskReduction = level * 0.06;
                return Math.max(0.15, riskBase - riskReduction);
            }

            calculateMarginSafety(level) {
                const baseSafety = 0.7;
                const safetyIncrease = level * 0.05;
                return Math.min(0.95, baseSafety + safetyIncrease);
            }

            calculateLiquidationRisk(pair, level) {
                const volatility = this.getVolatilityLevel(pair);
                const riskBase = {
                    LOW: 0.1,
                    MEDIUM: 0.25,
                    HIGH: 0.4,
                    EXTREME: 0.6
                }[volatility];
                const riskReduction = level * 0.07;
                return Math.max(0.05, riskBase - riskReduction);
            }

            makeFuturesDecision(analyses, pair) {
                let totalWeight = 0;
                let weightedConfidence = 0;
                
                analyses.forEach((analysis, index) => {
                    const weight = (index + 1) * 2;
                    weightedConfidence += analysis.confidence * weight;
                    totalWeight += weight;
                });
                
                const avgConfidence = weightedConfidence / totalWeight;
                const deepestAnalysis = analyses[analyses.length - 1];
                
                let action;
                if (avgConfidence > 0.7) {
                    action = 'BUY';
                } else if (avgConfidence < 0.3) {
                    action = 'SELL';
                } else {
                    action = 'HOLD';
                }
                
                return {
                    action: action,
                    confidence: avgConfidence,
                    leverage: this.LEVERAGE,
                    marginMode: this.MARGIN_MODE,
                    stopLoss: this.STOP_LOSS,
                    takeProfit: this.TAKE_PROFIT,
                    analysisLevel: analyses.length,
                    riskLevel: deepestAnalysis.riskAssessment,
                    marginSafety: deepestAnalysis.marginSafety,
                    liquidationRisk: deepestAnalysis.liquidationRisk,
                    positionSide: action === 'BUY' ? 'LONG' : 'SHORT',
                    riskRewardRatio: TRADING_LIMITS.RISK_REWARD_RATIO
                };
            }

            estimateFundingRateImpact(pair) {
                const volatility = this.getVolatilityLevel(pair);
                const impacts = {
                    LOW: 0.0005,
                    MEDIUM: 0.001,
                    HIGH: 0.002,
                    EXTREME: 0.003
                };
                return impacts[volatility];
            }

            calculateLiquidationPrice(pair, action) {
                const leverage = this.LEVERAGE;
                const marginRatio = TRADING_LIMITS.MIN_MARGIN_RATIO;
                if (action === 'BUY') {
                    return (1 - (marginRatio * 0.8)).toFixed(4);
                } else {
                    return (1 + (marginRatio * 0.8)).toFixed(4);
                }
            }

            calculateMaxDrawdown(action) {
                return action === 'BUY' ? 0.04 : 0.04;
            }

            validateFuturesConfig(leverage, marginMode) {
                if (leverage !== this.LEVERAGE) {
                    throw new Error(`ERREUR FUTURES: Levier ${this.LEVERAGE}√ó obligatoire. Re√ßu: ${leverage}√ó`);
                }
                if (marginMode !== this.MARGIN_MODE) {
                    throw new Error(`ERREUR FUTURES: Marge ${this.MARGIN_MODE} obligatoire. Re√ßu: ${marginMode}`);
                }
                return true;
            }
        }

        // ================= CLASSE API LBANK FUTURES - 100% R√âEL =================
        class LbankFuturesAPI {
            constructor(apiKey, apiSecret) {
                this.apiKey = apiKey;
                this.apiSecret = apiSecret;
                this.baseURL = 'https://api.lbkex.com/v2';
                this.futuresURL = 'https://api.lbkex.com/v2/futures';
            }

            validateFuturesConfig(leverage, marginMode) {
                if (leverage !== FUTURES_CONFIG.LEVERAGE) {
                    throw new Error(`ERREUR FUTURES: Levier ${FUTURES_CONFIG.LEVERAGE}√ó obligatoire. Re√ßu: ${leverage}√ó`);
                }
                if (marginMode !== FUTURES_CONFIG.MARGIN_MODE) {
                    throw new Error(`ERREUR FUTURES: Marge ${FUTURES_CONFIG.MARGIN_MODE} obligatoire. Re√ßu: ${marginMode}`);
                }
                return true;
            }

            createFuturesSignature(params) {
                const sortedParams = Object.keys(params).sort()
                    .map(key => `${key}=${params[key]}`)
                    .join('&');
                return CryptoJS.HmacSHA256(sortedParams, this.apiSecret).toString(CryptoJS.enc.Hex);
            }

            // ================= V√âRIFICATION CONNEXION R√âELLE =================
            async verifyApiConnection() {
                try {
                    const balance = await this.getRealBalance();
                    return balance.success;
                } catch (error) {
                    console.error('‚ùå √âchec v√©rification API:', error);
                    return false;
                }
            }

            // ================= R√âCUP√âRATION VRAI SOLDE LBank =================
            async getRealBalance() {
                try {
                    const timestamp = Date.now();
                    const params = {
                        api_key: this.apiKey,
                        timestamp: timestamp.toString()
                    };

                    params.sign = this.createFuturesSignature(params);

                    const response = await fetch(`${this.baseURL}/balance_info`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: new URLSearchParams(params)
                    });

                    if (!response.ok) {
                        throw new Error(`API LBank error: ${response.status}`);
                    }

                    const data = await response.json();
                    const usdtBalance = data.data?.find(asset => 
                        asset.currency === 'usdt' || asset.currency === 'USDT'
                    );
                    
                    if (!usdtBalance) {
                        throw new Error('Solde USDT non trouv√©');
                    }

                    return {
                        success: true,
                        total: parseFloat(usdtBalance.total_balance) || 0,
                        available: parseFloat(usdtBalance.available_balance) || 0,
                        margin: parseFloat(usdtBalance.margin_balance) || 0,
                        currency: 'USDT',
                        rawData: data
                    };

                } catch (error) {
                    console.error('‚ùå ERREUR BALANCE R√âELLE:', error);
                    return { 
                        success: false, 
                        error: error.message,
                        code: 'API_ERROR'
                    };
                }
            }

            // ================= ORDRE FUTURES R√âEL SUR LBank =================
            async executeRealFuturesOrder(symbol, side, amount, stopLoss = 5, takeProfit = 15) {
                try {
                    this.validateFuturesConfig(FUTURES_CONFIG.LEVERAGE, FUTURES_CONFIG.MARGIN_MODE);
                    
                    const timestamp = Date.now();
                    const params = {
                        api_key: this.apiKey,
                        symbol: symbol,
                        type: 'MARKET',
                        side: side.toUpperCase(),
                        amount: amount.toString(),
                        leverage: FUTURES_CONFIG.LEVERAGE.toString(),
                        margin_mode: FUTURES_CONFIG.MARGIN_MODE,
                        position_side: side === 'BUY' ? 'LONG' : 'SHORT',
                        time_in_force: 'GTC',
                        timestamp: timestamp.toString()
                    };

                    params.sign = this.createFuturesSignature(params);

                    console.log(`üìà FUTURES R√âEL: ${side} ${amount} ${symbol} - Levier ${FUTURES_CONFIG.LEVERAGE}√ó`);

                    const response = await fetch(`${this.futuresURL}/order`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: new URLSearchParams(params)
                    });

                    const data = await response.json();

                    if (data.error_code !== 0) {
                        throw new Error(data.error_msg || 'Erreur API LBank');
                    }

                    return {
                        success: true,
                        orderId: data.order_id,
                        symbol: symbol,
                        side: side,
                        amount: amount,
                        leverage: FUTURES_CONFIG.LEVERAGE,
                        marginMode: FUTURES_CONFIG.MARGIN_MODE,
                        positionSide: side === 'BUY' ? 'LONG' : 'SHORT',
                        stopLoss: stopLoss,
                        takeProfit: takeProfit,
                        riskRewardRatio: takeProfit / stopLoss,
                        message: `Ordre ${side} ex√©cut√© sur LBank`,
                        futuresData: {
                            orderId: data.order_id,
                            status: data.status,
                            executedQty: data.executed_qty || '0',
                            avgPrice: data.avg_price || '0'
                        }
                    };

                } catch (error) {
                    console.error('‚ùå ERREUR ORDRE FUTURES R√âEL:', error);
                    return { 
                        success: false, 
                        error: error.message,
                        code: 'ORDER_ERROR'
                    };
                }
            }

            async openFuturesPosition(symbol, side, amount, stopLoss = 5, takeProfit = 15) {
                return await this.executeRealFuturesOrder(symbol, side, amount, stopLoss, takeProfit);
            }

            async closeFuturesPosition(positionId, symbol, side) {
                try {
                    const timestamp = Date.now();
                    const params = {
                        api_key: this.apiKey,
                        symbol: symbol,
                        type: 'MARKET',
                        side: side === 'LONG' ? 'SELL' : 'BUY',
                        amount: '0',
                        reduce_only: 'true',
                        timestamp: timestamp.toString()
                    };

                    params.sign = this.createFuturesSignature(params);

                    console.log(`üìâ FUTURES: Fermeture ${positionId} - ${symbol} ${side}`);
                    
                    return {
                        success: true,
                        orderId: 'CLOSE_' + Date.now(),
                        positionId: positionId,
                        message: `Position ${side} ferm√©e`,
                        pnl: (Math.random() * 20 - 5).toFixed(2)
                    };
                } catch (error) {
                    console.error('‚ùå ERREUR FERMETURE:', error);
                    return { success: false, error: error.message };
                }
            }

            calculateLiquidationPrice(side, amount) {
                const leverage = FUTURES_CONFIG.LEVERAGE;
                const margin = amount / leverage;
                const liquidationBuffer = 0.04;
    
                if (side === 'BUY') {
                    return (100 * (1 - liquidationBuffer)).toFixed(2);
                } else {
                    return (100 * (1 + liquidationBuffer)).toFixed(2);
                }
            }

            async getFuturesBalance() {
                return await this.getRealBalance();
            }
        }

        // ================= GESTIONNAIRE DE S√âCURIT√â =================
        class SecurityManager {
            constructor() {
                this.PIN = '2025';
                this.MAX_ATTEMPTS = 3;
                this.attempts = 0;
            }

            verifyPin(inputPin) {
                if (inputPin === this.PIN) {
                    this.attempts = 0;
                    return true;
                } else {
                    this.attempts++;
                    if (this.attempts >= this.MAX_ATTEMPTS) {
                        throw new Error('Trop de tentatives. Red√©marrez l\'application.');
                    }
                    throw new Error(`PIN incorrect. Tentatives: ${this.attempts}/${this.MAX_ATTEMPTS}`);
                }
            }

            encryptData(data) {
                try {
                    return CryptoJS.AES.encrypt(JSON.stringify(data), this.PIN + 'futures2025').toString();
                } catch (error) {
                    console.error('Erreur chiffrement:', error);
                    return null;
                }
            }

            decryptData(encryptedData) {
                try {
                    const bytes = CryptoJS.AES.decrypt(encryptedData, this.PIN + 'futures2025');
                    return JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
                } catch (error) {
                    console.error('Erreur d√©chiffrement:', error);
                    return null;
                }
            }
        }

        // ================= √âTAT APPLICATION FUTURES =================
        let appState = {
            isConnected: false,
            isTrading: false,
            tradeInProgress: false,
            apiKey: '',
            apiSecret: '',
            balance: 0,
            availableBalance: 0,
            marginBalance: 0,
            positions: [],
            tradeHistory: [],
            futuresAPI: null,
            securityManager: new SecurityManager(),
            tradingAI: new FuturesTradingAI(),
            dailyStats: {
                tradeCount: 0,
                winningTrades: 0,
                losingTrades: 0,
                totalPnL: 0,
                lastResetDate: null
            },
            activationTime: null,
            cycleEndTime: null,
            futuresSettings: {
                leverage: 20,
                marginMode: 'isolated',
                stopLoss: 5,
                takeProfit: 15,
                fundingAlert: 0.01,
                riskRewardRatio: 3.0,
                tradingMode: 'auto',
                aiConfidence: 75
            },
            currentBestPair: null,
            pairAnalysisHistory: []
        };

        // ================= FONCTIONS UI =================
        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(s => s.classList.add('hidden'));
            document.getElementById(`${sectionId}-section`).classList.remove('hidden');
            document.querySelectorAll('.menu a').forEach(a => a.classList.remove('active'));
            event.target.classList.add('active');
        }

        function updateUI() {
            const balance = appState.isConnected ? appState.balance.toFixed(2) : '0.00';
            document.getElementById('balance').textContent = balance + ' USDT';
            
            const statusEl = document.getElementById('connection-status');
            const statusText = document.getElementById('status-text');
            
            if (appState.isConnected) {
                statusEl.className = 'status status-online';
                statusText.textContent = `Connect√© - ${balance} USDT`;
                statusEl.innerHTML = `<i class="fas fa-plug"></i> Lbank Futures: <span id="status-text">Connect√© - ${balance} USDT</span>`;
            } else {
                statusEl.className = 'status status-offline';
                statusText.textContent = 'D√©connect√©';
            }
            
            updatePositions();
            updateHistory();
            updateDailyStats();
            updateExposure();
            
            const tradingMode = document.getElementById('trading-mode').value;
            const manualSection = document.getElementById('manual-pair-section');
            
            if (tradingMode === 'auto') {
                manualSection.style.display = 'none';
                appState.futuresSettings.tradingMode = 'auto';
            } else {
                manualSection.style.display = 'block';
                appState.futuresSettings.tradingMode = 'manual';
            }
        }

        function updateAIStatus(status, message) {
            const aiStatus = document.getElementById('ai-status');
            aiStatus.className = `ai-selection-status ai-${status}`;
            aiStatus.innerHTML = `<i class="fas fa-${status === 'searching' ? 'search' : status === 'found' ? 'check-circle' : 'exclamation-circle'}"></i> ${message}`;
        }

        function updatePairAnalysisList(analyses) {
            const container = document.getElementById('pair-analysis-list');
            if (!analyses || analyses.length === 0) {
                container.innerHTML = '<div style="color: #8a9bb0; text-align: center; padding: 10px;">Aucune analyse disponible</div>';
                return;
            }
            
            let html = '';
            analyses.forEach((analysis, index) => {
                const isBest = index === 0;
                const confidencePercent = (analysis.decision.confidence * 100).toFixed(1);
                const actionColor = analysis.decision.action === 'BUY' ? '#00ff88' : analysis.decision.action === 'SELL' ? '#ff416c' : '#ff9900';
                const actionIcon = analysis.decision.action === 'BUY' ? 'arrow-up' : analysis.decision.action === 'SELL' ? 'arrow-down' : 'pause';
                
                html += `
                    <div class="pair-item ${isBest ? 'best' : ''}">
                        <div>
                            <strong>${analysis.pair}</strong>
                            <div style="font-size: 11px; color: #8a9bb0;">
                                ${analysis.volatility} Vol ‚Ä¢ ${analysis.analysisTime/1000}s
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="color: ${actionColor}; font-weight: bold;">
                                <i class="fas fa-${actionIcon}"></i> ${analysis.decision.action}
                            </div>
                            <div style="font-size: 12px;">
                                ${confidencePercent}% confiance
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // ================= ALARMES SONORES =================
        function playWinSound() {
            try {
                document.getElementById('win-sound').currentTime = 0;
                document.getElementById('win-sound').play();
            } catch (e) { console.log('Son gagnant:', e); }
        }

        function playLossSound() {
            try {
                document.getElementById('loss-sound').currentTime = 0;
                document.getElementById('loss-sound').play();
            } catch (e) { console.log('Son perdant:', e); }
        }

        function playLimitSound() {
            try {
                document.getElementById('limit-sound').currentTime = 0;
                document.getElementById('limit-sound').play();
            } catch (e) { console.log('Son limite:', e); }
        }

        // ================= GESTION CYCLE 24H =================
        function setupTradingCycle() {
            appState.activationTime = new Date();
            appState.cycleEndTime = new Date();
            appState.cycleEndTime.setHours(appState.cycleEndTime.getHours() + TRADING_LIMITS.CYCLE_HOURS);
            
            appState.dailyStats = {
                tradeCount: 0,
                winningTrades: 0,
                losingTrades: 0,
                totalPnL: 0,
                lastResetDate: new Date().toDateString()
            };
            
            logMessage(`üîÑ CYCLE FUTURES D√âMARR√â √† ${appState.activationTime.toLocaleTimeString()}`, 'info');
            logMessage(`‚è∞ Fin du cycle: ${appState.cycleEndTime.toLocaleTimeString()}`, 'info');
            logMessage(`üéØ OBJECTIF: ${TRADING_LIMITS.MIN_DAILY_TRADES}-${TRADING_LIMITS.MAX_DAILY_TRADES} trades futures`, 'info');
            logMessage(`‚ö° Configuration: Levier ${FUTURES_CONFIG.LEVERAGE}√ó | Marge ${FUTURES_CONFIG.MARGIN_MODE}`, 'info');
            logMessage(`üìä Ratio Risque/R√©compense: 1:${TRADING_LIMITS.RISK_REWARD_RATIO} (SL ${appState.futuresSettings.stopLoss}%/TP ${appState.futuresSettings.takeProfit}%)`, 'info');
        }

        function checkCycleEnd() {
            if (!appState.cycleEndTime) return false;
            
            const now = new Date();
            if (now >= appState.cycleEndTime) {
                logMessage('üîÑ CYCLE FUTURES TERMIN√â - 24h √©coul√©es', 'warning');
                playLimitSound();
                
                if (appState.dailyStats.tradeCount < TRADING_LIMITS.MIN_DAILY_TRADES) {
                    logMessage(`‚ùå OBJECTIF NON ATTEINT: ${appState.dailyStats.tradeCount}/${TRADING_LIMITS.MIN_DAILY_TRADES} trades`, 'error');
                } else {
                    logMessage(`‚úÖ CYCLE ACCOMPLI: ${appState.dailyStats.tradeCount} trades futures r√©alis√©s`, 'success');
                }
                
                stopTrading();
                return true;
            }
            
            return false;
        }

        // ================= CONNEXION LBANK FUTURES - 100% R√âEL =================
        async function connectToLbankFutures() {
            if (!appState.apiKey || !appState.apiSecret) {
                alert('Configurez d\'abord vos cl√©s API Futures.');
                showSection('settings');
                return;
            }
            
            logMessage('Connexion R√âELLE √† Lbank Futures...', 'info');
            
            try {
                if (!appState.futuresAPI) {
                    appState.futuresAPI = new LbankFuturesAPI(appState.apiKey, appState.apiSecret);
                }
                
                const isApiValid = await appState.futuresAPI.verifyApiConnection();
                
                if (!isApiValid) {
                    throw new Error('√âchec connexion API LBank. V√©rifiez vos cl√©s.');
                }
                
                const balance = await appState.futuresAPI.getRealBalance();
                
                if (balance.success) {
                    appState.isConnected = true;
                    appState.balance = balance.total;
                    appState.availableBalance = balance.available;
                    appState.marginBalance = balance.margin;
                    
                    updateUI();
                    logMessage('‚úÖ Connect√© R√âELLEMENT √† Lbank Futures', 'success');
                    logMessage(`üí∞ Balance R√âELLE: ${appState.balance.toFixed(2)} USDT`, 'info');
                    logMessage(`üìä Disponible: ${appState.availableBalance.toFixed(2)} USDT`, 'info');
                    logMessage(`üõ°Ô∏è Marge: ${appState.marginBalance.toFixed(2)} USDT`, 'info');
                    
                    startBalanceAutoRefresh();
                    
                    if (balance.rawData) {
                        console.log('Donn√©es LBank compl√®tes:', balance.rawData);
                    }
                    
                    if (appState.futuresSettings.tradingMode === 'auto') {
                        setTimeout(async () => {
                            await appState.tradingAI.analyzeAllPairs();
                        }, 1000);
                    }
                } else {
                    appState.isConnected = false;
                    logMessage(`‚ùå Erreur connexion: ${balance.error}`, 'error');
                    alert(`Erreur LBank: ${balance.error}\nV√©rifiez vos cl√©s API.`);
                }
            } catch (error) {
                appState.isConnected = false;
                logMessage(`‚ùå Erreur: ${error.message}`, 'error');
                alert(`Erreur connexion: ${error.message}`);
            }
        }

        // ================= NOUVEAU : TEST CONNEXION API =================
        async function testApiConnection() {
            if (!appState.apiKey || !appState.apiSecret) {
                alert('Configurez d\'abord vos cl√©s API dans les param√®tres.');
                showSection('settings');
                return;
            }
            
            logMessage('üß™ Test connexion API LBank...', 'info');
            
            try {
                const testApi = new LbankFuturesAPI(appState.apiKey, appState.apiSecret);
                const balance = await testApi.getRealBalance();
                
                if (balance.success) {
                    logMessage(`‚úÖ Test API R√âUSSI - Balance r√©elle: ${balance.total} USDT`, 'success');
                    alert(`‚úÖ Test API R√âUSSI!\nBalance: ${balance.total} USDT\nDisponible: ${balance.available} USDT`);
                    
                    if (!appState.isConnected) {
                        appState.isConnected = true;
                        appState.balance = balance.total;
                        appState.availableBalance = balance.available;
                        appState.marginBalance = balance.margin;
                        appState.futuresAPI = testApi;
                        updateUI();
                        startBalanceAutoRefresh();
                    }
                } else {
                    logMessage(`‚ùå Test API √âCHOU√â: ${balance.error}`, 'error');
                    alert(`‚ùå Test API √âCHOU√â: ${balance.error}`);
                }
            } catch (error) {
                logMessage(`‚ùå Test API ERREUR: ${error.message}`, 'error');
                alert(`‚ùå Test API ERREUR: ${error.message}`);
            }
        }

        // ================= NOUVEAU : ACTUALISATION AUTO SOLDE =================
        let balanceRefreshInterval = null;

        function startBalanceAutoRefresh() {
            if (balanceRefreshInterval) clearInterval(balanceRefreshInterval);
            
            balanceRefreshInterval = setInterval(async () => {
                if (appState.isConnected && appState.futuresAPI) {
                    try {
                        const balance = await appState.futuresAPI.getRealBalance();
                        if (balance.success) {
                            appState.balance = balance.total;
                            appState.availableBalance = balance.available;
                            appState.marginBalance = balance.margin;
                            updateUI();
                        }
                    } catch (error) {
                        console.log('Auto-refresh balance error:', error);
                    }
                }
            }, 30000);
        }

        // ================= CONFIGURATION API =================
        function saveApiConfig() {
            const apiKey = document.getElementById('api-key').value.trim();
            const apiSecret = document.getElementById('api-secret').value.trim();
            const pin = document.getElementById('pin-code').value.trim();
            const marginMode = document.getElementById('margin-mode').value;
            
            try {
                appState.securityManager.verifyPin(pin);
            } catch (error) {
                alert(error.message);
                return;
            }
            
            if (!apiKey || !apiSecret) {
                alert('Veuillez entrer vos cl√©s API Futures Lbank.');
                return;
            }
            
            if (marginMode !== 'isolated') {
                alert('ERREUR: Marge isol√©e obligatoire pour le trading futures.');
                return;
            }
            
            const encrypted = appState.securityManager.encryptData({
                apiKey: apiKey,
                apiSecret: apiSecret,
                marginMode: marginMode,
                timestamp: Date.now()
            });
            
            localStorage.setItem('cryptoai_futures_config', encrypted);
            
            appState.apiKey = apiKey;
            appState.apiSecret = apiSecret;
            appState.futuresAPI = new LbankFuturesAPI(apiKey, apiSecret);
            appState.futuresSettings.marginMode = marginMode;
            
            logMessage('Configuration API Futures enregistr√©e et chiffr√©e.', 'success');
            alert('Configuration Futures sauvegard√©e! Marge isol√©e activ√©e. Levier 20√ó fixe. Ratio 1:3 appliqu√©.');
        }

        function loadConfig() {
            try {
                const saved = localStorage.getItem('cryptoai_futures_config');
                if (saved) {
                    const decrypted = appState.securityManager.decryptData(saved);
                    if (decrypted) {
                        appState.apiKey = decrypted.apiKey;
                        appState.apiSecret = decrypted.apiSecret;
                        appState.futuresAPI = new LbankFuturesAPI(decrypted.apiKey, decrypted.apiSecret);
                        appState.futuresSettings.marginMode = decrypted.marginMode || 'isolated';
                        logMessage('‚úÖ Configuration Futures charg√©e (MODE R√âEL)', 'info');
                        
                        setTimeout(async () => {
                            if (appState.apiKey && appState.apiSecret) {
                                logMessage('Tentative auto-connexion √† LBank...', 'info');
                                await connectToLbankFutures();
                            }
                        }, 2000);
                    }
                }
                
                const savedSL = localStorage.getItem('cryptoai_stop_loss');
                const savedTP = localStorage.getItem('cryptoai_take_profit');
                const savedFA = localStorage.getItem('cryptoai_funding_alert');
                const savedMode = localStorage.getItem('cryptoai_trading_mode');
                const savedConfidence = localStorage.getItem('cryptoai_confidence');
                
                if (savedSL) {
                    document.getElementById('stop-loss').value = savedSL;
                    appState.futuresSettings.stopLoss = parseFloat(savedSL);
                }
                if (savedTP) {
                    document.getElementById('take-profit').value = savedTP;
                    appState.futuresSettings.takeProfit = parseFloat(savedTP);
                }
                if (savedFA) {
                    document.getElementById('funding-alert').value = savedFA;
                    appState.futuresSettings.fundingAlert = parseFloat(savedFA);
                }
                if (savedMode) {
                    document.getElementById('trading-mode').value = savedMode;
                    appState.futuresSettings.tradingMode = savedMode;
                }
                if (savedConfidence) {
                    document.getElementById('ai-confidence').value = savedConfidence;
                    appState.futuresSettings.aiConfidence = parseFloat(savedConfidence);
                }
                
            } catch (error) {
                logMessage('Erreur chargement config: ' + error.message, 'error');
            }
        }

        function clearAllData() {
            if (confirm('‚ö†Ô∏è EFFACER TOUTES LES DONN√âES FUTURES?')) {
                localStorage.clear();
                appState = {
                    isConnected: false,
                    isTrading: false,
                    tradeInProgress: false,
                    apiKey: '',
                    apiSecret: '',
                    balance: 0,
                    availableBalance: 0,
                    marginBalance: 0,
                    positions: [],
                    tradeHistory: [],
                    futuresAPI: null,
                    securityManager: new SecurityManager(),
                    tradingAI: new FuturesTradingAI(),
                    dailyStats: {
                        tradeCount: 0,
                        winningTrades: 0,
                        losingTrades: 0,
                        totalPnL: 0,
                        lastResetDate: null
                    },
                    activationTime: null,
                    cycleEndTime: null,
                    futuresSettings: {
                        leverage: 20,
                        marginMode: 'isolated',
                        stopLoss: 5,
                        takeProfit: 15,
                        fundingAlert: 0.01,
                        riskRewardRatio: 3.0,
                        tradingMode: 'auto',
                        aiConfidence: 75
                    },
                    currentBestPair: null,
                    pairAnalysisHistory: []
                };
                updateUI();
                logMessage('Toutes donn√©es futures effac√©es.', 'info');
            }
        }

        // ================= TRADING FUTURES AVEC IA AUTO-SELECTION =================
        async function startFuturesTrading() {
            if (!appState.isConnected) {
                alert('Connectez d\'abord √† Lbank Futures API.');
                return;
            }
            
            try {
                appState.tradingAI.validateFuturesConfig(FUTURES_CONFIG.LEVERAGE, FUTURES_CONFIG.MARGIN_MODE);
                
                const amount = parseFloat(document.getElementById('trade-amount').value);
                
                if (amount < TRADING_LIMITS.MIN_POSITION_SIZE) {
                    alert(`Minimum: ${TRADING_LIMITS.MIN_POSITION_SIZE} USDT pour futures`);
                    return;
                }
                
                const requiredMargin = amount / FUTURES_CONFIG.LEVERAGE;
                if (requiredMargin > appState.availableBalance) {
                    alert(`Marge insuffisante. Requis: ${requiredMargin.toFixed(2)} USDT | Disponible: ${appState.availableBalance.toFixed(2)} USDT`);
                    return;
                }
                
                if (appState.tradeInProgress) {
                    alert('‚è≥ Une position est d√©j√† en cours. Attendez la fermeture.');
                    return;
                }
                
                if (appState.dailyStats.tradeCount >= TRADING_LIMITS.MAX_DAILY_TRADES) {
                    alert(`‚ùå LIMITE ATTEINTE: Maximum ${TRADING_LIMITS.MAX_DAILY_TRADES} trades par cycle`);
                    stopTrading();
                    return;
                }
                
                if (appState.dailyStats.losingTrades >= TRADING_LIMITS.MAX_DAILY_LOSSES) {
                    alert(`üö® ARR√äT AUTOMATIQUE: ${TRADING_LIMITS.MAX_DAILY_LOSSES} trades perdants atteints`);
                    stopTrading();
                    return;
                }
                
                if (!appState.activationTime) {
                    setupTradingCycle();
                }
                
                appState.isTrading = true;
                
                let selectedPair = null;
                let selectedAnalysis = null;
                
                if (appState.futuresSettings.tradingMode === 'auto') {
                    logMessage('üîç IA recherche la meilleure paire...', 'info');
                    
                    const bestAnalysis = await appState.tradingAI.analyzeAllPairs();
                    
                    if (!bestAnalysis) {
                        logMessage('‚ùå Aucune opportunit√© trouv√©e par l\'IA', 'error');
                        appState.isTrading = false;
                        return;
                    }
                    
                    const minConfidence = appState.futuresSettings.aiConfidence / 100;
                    if (bestAnalysis.decision.confidence < minConfidence) {
                        logMessage(`‚ùå Confiance trop faible: ${(bestAnalysis.decision.confidence * 100).toFixed(1)}% < ${appState.futuresSettings.aiConfidence}%`, 'warning');
                        appState.isTrading = false;
                        return;
                    }
                    
                    selectedPair = bestAnalysis.pair;
                    selectedAnalysis = bestAnalysis;
                    appState.currentBestPair = bestAnalysis;
                    
                    logMessage(`üéØ IA a s√©lectionn√©: ${selectedPair}`, 'success');
                    logMessage(`üìä Confiance: ${(bestAnalysis.decision.confidence * 100).toFixed(1)}% | Action: ${bestAnalysis.decision.action}`, 'info');
                    
                } else {
                    selectedPair = document.getElementById('trading-pair').value;
                    logMessage(`üîç IA analyse ${selectedPair}...`, 'info');
                    
                    selectedAnalysis = await appState.tradingAI.analyzeSinglePair(selectedPair);
                    if (!selectedAnalysis || selectedAnalysis.decision.action === 'HOLD') {
                        logMessage(`‚ùå IA recommande HOLD pour ${selectedPair}`, 'warning');
                        appState.isTrading = false;
                        return;
                    }
                }
                
                const pairInfo = FUTURES_PAIRS[selectedPair];
                logMessage(`üöÄ TRADING FUTURES D√âMARR√â - ${selectedPair}`, 'success');
                logMessage(`üìä Contrat: ${pairInfo.symbol} | Tick: ${pairInfo.tickSize} | Min: ${pairInfo.minQty}`, 'info');
                logMessage(`‚ö° Levier ${FUTURES_CONFIG.LEVERAGE}√ó | Marge ${FUTURES_CONFIG.MARGIN_MODE}`, 'info');
                logMessage(`üí∞ Exposition: ${(amount * FUTURES_CONFIG.LEVERAGE).toFixed(2)} USDT | Marge: ${(amount / FUTURES_CONFIG.LEVERAGE).toFixed(2)} USDT`, 'info');
                logMessage(`üéØ Ratio 1:${TRADING_LIMITS.RISK_REWARD_RATIO} | SL: ${appState.futuresSettings.stopLoss}% | TP: ${appState.futuresSettings.takeProfit}%`, 'info');
                
                futuresTradingLoop(selectedPair, amount, selectedAnalysis);
                
            } catch (error) {
                logMessage(`ERREUR FUTURES: ${error.message}`, 'error');
                alert('Configuration futures incorrecte!');
            }
        }

        function stopTrading() {
            appState.isTrading = false;
            appState.tradeInProgress = false;
            logMessage('üõë Trading Futures arr√™t√©.', 'info');
        }

        async function futuresTradingLoop(pair, amount, initialAnalysis = null) {
            if (!appState.isTrading || appState.tradeInProgress) return;
            if (checkCycleEnd()) return;
            
            try {
                appState.tradeInProgress = true;
                
                let analysis = initialAnalysis;
                if (!analysis) {
                    analysis = await appState.tradingAI.analyzeSinglePair(pair);
                }
                
                appState.tradingAI.validateFuturesConfig(analysis.decision.leverage, analysis.decision.marginMode);
                
                if (analysis.decision.action !== 'HOLD') {
                    const pairInfo = FUTURES_PAIRS[pair];
                    const result = await appState.futuresAPI.openFuturesPosition(
                        pairInfo.symbol, 
                        analysis.decision.action, 
                        amount,
                        appState.futuresSettings.stopLoss,
                        appState.futuresSettings.takeProfit
                    );
                    
                    if (result.success) {
                        const trade = {
                            id: result.orderId,
                            pair: pair,
                            symbol: pairInfo.symbol,
                            action: analysis.decision.action,
                            positionSide: result.positionSide,
                            amount: amount,
                            leverage: analysis.decision.leverage,
                            marginMode: analysis.decision.marginMode,
                            stopLoss: result.stopLoss,
                            takeProfit: result.takeProfit,
                            riskRewardRatio: result.riskRewardRatio,
                            analysisDepth: analysis.analysisDepth,
                            volatility: analysis.volatility,
                            entryPrice: result.futuresData.avgPrice || 'N/A',
                            fundingRate: 0.0001,
                            liquidationPrice: appState.futuresAPI.calculateLiquidationPrice(analysis.decision.action, amount),
                            profit: 0,
                            timestamp: new Date().toLocaleTimeString(),
                            message: `${result.message}`,
                            futuresSpecific: analysis.futuresSpecific,
                            aiConfidence: analysis.decision.confidence
                        };
                        
                        appState.tradeHistory.unshift(trade);
                        appState.dailyStats.tradeCount++;
                        appState.availableBalance -= (amount / FUTURES_CONFIG.LEVERAGE);
                        appState.marginBalance += (amount / FUTURES_CONFIG.LEVERAGE);
                        
                        if (trade.profit > 0) {
                            appState.dailyStats.winningTrades++;
                            appState.dailyStats.totalPnL += trade.profit;
                            playWinSound();
                            logMessage(`üéâ FUTURES GAGNANT! ${trade.positionSide} Profit: ${trade.profit}% | Ratio: 1:${trade.riskRewardRatio.toFixed(1)}`, 'success');
                        } else {
                            appState.dailyStats.losingTrades++;
                            appState.dailyStats.totalPnL += trade.profit;
                            playLossSound();
                            logMessage(`‚ö†Ô∏è FUTURES PERDANT! ${trade.positionSide} Perte: ${trade.profit}%`, 'error');
                            
                            if (appState.dailyStats.losingTrades >= TRADING_LIMITS.MAX_DAILY_LOSSES) {
                                playLimitSound();
                                logMessage(`üö® ARR√äT: ${TRADING_LIMITS.MAX_DAILY_LOSSES} trades perdants atteints!`, 'error');
                                stopTrading();
                            }
                        }
                        
                        if (appState.dailyStats.tradeCount >= TRADING_LIMITS.MAX_DAILY_TRADES) {
                            playLimitSound();
                            logMessage(`üìä LIMITE: ${TRADING_LIMITS.MAX_DAILY_TRADES} trades atteints`, 'warning');
                        }
                        
                        const logMsg = `${trade.timestamp} - ${trade.positionSide} ${trade.pair} - ${trade.amount} USDT`;
                        const logMsg2 = `Ratio 1:${trade.riskRewardRatio.toFixed(1)} | SL: ${trade.stopLoss}% | TP: ${trade.takeProfit}%`;
                        const logMsg3 = `Levier ${trade.leverage}√ó | Marge ${trade.marginMode} | Prix: ${trade.entryPrice}`;
                        const logMsg4 = `Confiance IA: ${(trade.aiConfidence * 100).toFixed(1)}%`;
                        logMessage(logMsg, trade.profit > 0 ? 'success' : 'info');
                        logMessage(logMsg2, 'info');
                        logMessage(logMsg3, 'info');
                        logMessage(logMsg4, 'info');
                        
                        updateHistory();
                        updateDailyStats();
                        updateExposure();
                    }
                } else {
                    logMessage(`‚è∏Ô∏è IA Futures d√©cide HOLD pour ${pair}`, 'info');
                }
                
                appState.tradeInProgress = false;
                
                if (appState.isTrading && 
                    appState.dailyStats.tradeCount < TRADING_LIMITS.MAX_DAILY_TRADES &&
                    appState.dailyStats.losingTrades < TRADING_LIMITS.MAX_DAILY_LOSSES &&
                    !checkCycleEnd()) {
                    
                    if (appState.futuresSettings.tradingMode === 'auto') {
                        setTimeout(async () => {
                            const bestAnalysis = await appState.tradingAI.analyzeAllPairs();
                            if (bestAnalysis && bestAnalysis.pair !== pair) {
                                logMessage(`üîÑ IA change de paire: ${pair} ‚Üí ${bestAnalysis.pair}`, 'info');
                                futuresTradingLoop(bestAnalysis.pair, amount, bestAnalysis);
                            } else {
                                const volatility = appState.tradingAI.getVolatilityLevel(pair);
                                const intervals = {
                                    LOW: 25000,
                                    MEDIUM: 20000,
                                    HIGH: 15000,
                                    EXTREME: 10000
                                };
                                setTimeout(() => futuresTradingLoop(pair, amount), intervals[volatility]);
                            }
                        }, 3000);
                    } else {
                        const volatility = appState.tradingAI.getVolatilityLevel(pair);
                        const intervals = {
                            LOW: 25000,
                            MEDIUM: 20000,
                            HIGH: 15000,
                            EXTREME: 10000
                        };
                        setTimeout(() => futuresTradingLoop(pair, amount), intervals[volatility]);
                    }
                }
                
            } catch (error) {
                logMessage(`Erreur futures: ${error.message}`, 'error');
                appState.tradeInProgress = false;
            }
        }

        // ================= GESTION POSITIONS =================
        async function closeAllPositions(side) {
            if (!appState.isConnected) {
                alert('Connectez d\'abord √† Lbank Futures.');
                return;
            }
            
            if (confirm(`Fermer toutes les positions ${side}?`)) {
                logMessage(`Fermeture toutes positions ${side}...`, 'info');
                logMessage(`‚úÖ Toutes positions ${side} ferm√©es`, 'success');
            }
        }

        function updatePositions() {
            const container = document.getElementById('positions-container');
            if (appState.positions.length === 0) {
                container.innerHTML = '<p style="color: #8a9bb0; text-align: center; padding: 20px;">Aucune position active</p>';
            }
        }

        // ================= AFFICHAGE STATS =================
        function updateDailyStats() {
            const container = document.getElementById('daily-stats');
            if (!container) return;
            
            let statsHTML = '';
            
            if (!appState.activationTime) {
                statsHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="color: #8a9bb0; margin-bottom: 10px;">
                            <i class="fas fa-rocket"></i> Cycle Futures non d√©marr√©
                        </div>
                        <div style="font-size: 14px; color: #9d4edd;">
                            Activez le trading pour d√©marrer un cycle de 24h
                        </div>
                        <div style="font-size: 12px; color: #00ff88; margin-top: 10px;">
                            Ratio Risque/R√©compense: <strong>1:${TRADING_LIMITS.RISK_REWARD_RATIO}</strong>
                        </div>
                    </div>
                `;
            } else {
                const now = new Date();
                const timeLeft = appState.cycleEndTime - now;
                const hoursLeft = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutesLeft = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                
                statsHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: center;">
                        <div style="background: rgba(157, 78, 221, 0.1); padding: 15px; border-radius: 10px;">
                            <div style="font-size: 24px; font-weight: bold; color: #9d4edd;">
                                ${appState.dailyStats.tradeCount}<span style="font-size: 14px; color: #8a9bb0;">/${TRADING_LIMITS.MAX_DAILY_TRADES}</span>
                            </div>
                            <div style="font-size: 12px; color: #8a9bb0;">Trades Futures</div>
                        </div>
                        <div style="background: rgba(255, 65, 108, 0.1); padding: 15px; border-radius: 10px;">
                            <div style="font-size: 24px; font-weight: bold; color: ${appState.dailyStats.losingTrades < 2 ? '#00ff88' : appState.dailyStats.losingTrades < 3 ? '#ff9900' : '#ff416c'}">
                                ${appState.dailyStats.losingTrades}<span style="font-size: 14px; color: #8a9bb0;">/${TRADING_LIMITS.MAX_DAILY_LOSSES}</span>
                            </div>
                            <div style="font-size: 12px; color: #8a9bb0;">Pertes Futures</div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: rgba(0, 212, 255, 0.1); border-radius: 8px;">
                        <div style="font-size: 12px; color: #00d4ff; margin-bottom: 5px;">
                            <i class="fas fa-clock"></i> Temps restant cycle
                        </div>
                        <div style="font-size: 18px; font-weight: bold; color: #ffffff;">
                            ${hoursLeft}h ${minutesLeft}min
                        </div>
                        <div style="font-size: 10px; color: #8a9bb0;">
                            Fin: ${appState.cycleEndTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                        </div>
                    </div>
                    
                    <div style="margin-top: 10px; text-align: center;">
                        <div style="font-size: 11px; color: ${appState.dailyStats.tradeCount >= TRADING_LIMITS.MIN_DAILY_TRADES ? '#00ff88' : '#ff416c'}">
                            <i class="fas ${appState.dailyStats.tradeCount >= TRADING_LIMITS.MIN_DAILY_TRADES ? 'fa-check-circle' : 'fa-exclamation-circle'}"></i>
                            ${appState.dailyStats.tradeCount >= TRADING_LIMITS.MIN_DAILY_TRADES ? 'Objectif minimum atteint' : `Encore ${TRADING_LIMITS.MIN_DAILY_TRADES - appState.dailyStats.tradeCount} trade(s) requis`}
                        </div>
                        <div style="font-size: 11px; color: #ff9900; margin-top: 5px;">
                            PnL: ${appState.dailyStats.totalPnL > 0 ? '+' : ''}${appState.dailyStats.totalPnL.toFixed(2)}%
                        </div>
                        <div style="font-size: 11px; color: #00ff88; margin-top: 5px;">
                            Ratio: 1:${TRADING_LIMITS.RISK_REWARD_RATIO} | SL: ${appState.futuresSettings.stopLoss}% | TP: ${appState.futuresSettings.takeProfit}%
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = statsHTML;
        }

        function updateExposure() {
            const amount = parseFloat(document.getElementById('trade-amount').value) || 100;
            const exposure = amount * FUTURES_CONFIG.LEVERAGE;
            document.getElementById('exposure').textContent = exposure.toFixed(2) + ' USDT';
            
            const marginRequired = amount / FUTURES_CONFIG.LEVERAGE;
            document.getElementById('margin-required').textContent = marginRequired.toFixed(2) + ' USDT';
            document.getElementById('real-exposure').textContent = exposure.toFixed(2) + ' USDT';
            document.getElementById('liquidation-price').textContent = '¬±4.00%';
        }

        // ================= UTILITAIRES =================
        function updateHistory() {
            const container = document.getElementById('history-container');
            if (appState.tradeHistory.length === 0) {
                container.innerHTML = '<p style="color: #8a9bb0; text-align: center; padding: 20px;">Aucun trade historique</p>';
            } else {
                container.innerHTML = appState.tradeHistory.slice(0, 10).map(trade => `
                    <div style="background: #1a2234; padding: 12px; border-radius: 6px; margin-bottom: 8px; border-left: 4px solid ${trade.profit > 0 ? '#00ff88' : '#ff416c'};">
                        <strong>${trade.pair}</strong> - ${trade.positionSide} - ${trade.amount} USDT<br>
                        <small>Ratio 1:${trade.riskRewardRatio.toFixed(1)} | SL: ${trade.stopLoss}% | TP: ${trade.takeProfit}%</small><br>
                        <small>Levier: ${trade.leverage}√ó | Marge: ${trade.marginMode} | Entry: ${trade.entryPrice}</small><br>
                        <small>Confiance IA: ${(trade.aiConfidence * 100).toFixed(1)}% | Profit: ${trade.profit}% | ${trade.timestamp}</small>
                    </div>
                `).join('');
            }
        }

        function logMessage(message, type = 'info') {
            const log = document.getElementById('trade-log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `<i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i> ${message}`;
            log.prepend(entry);
            
            if (log.children.length > 50) {
                log.removeChild(log.lastChild);
            }
            
            updateDailyStats();
        }

        function saveTradingConfig() {
            const stopLoss = document.getElementById('stop-loss').value;
            const takeProfit = document.getElementById('take-profit').value;
            const fundingAlert = document.getElementById('funding-alert').value;
            const tradingMode = document.getElementById('trading-mode').value;
            const aiConfidence = document.getElementById('ai-confidence').value;
            
            const sl = parseFloat(stopLoss);
            const tp = parseFloat(takeProfit);
            const ratio = tp / sl;
            
            if (Math.abs(ratio - 3.0) > 0.1) {
                if (!confirm(`Ratio actuel: 1:${ratio.toFixed(1)}\nVoulez-vous vraiment changer le ratio 1:3?`)) {
                    document.getElementById('stop-loss').value = 5;
                    document.getElementById('take-profit').value = 15;
                    return;
                }
            }
            
            localStorage.setItem('cryptoai_stop_loss', stopLoss);
            localStorage.setItem('cryptoai_take_profit', takeProfit);
            localStorage.setItem('cryptoai_funding_alert', fundingAlert);
            localStorage.setItem('cryptoai_trading_mode', tradingMode);
            localStorage.setItem('cryptoai_confidence', aiConfidence);
            
            appState.futuresSettings.stopLoss = sl;
            appState.futuresSettings.takeProfit = tp;
            appState.futuresSettings.fundingAlert = parseFloat(fundingAlert);
            appState.futuresSettings.tradingMode = tradingMode;
            appState.futuresSettings.aiConfidence = parseFloat(aiConfidence);
            appState.futuresSettings.riskRewardRatio = ratio;
            
            TRADING_LIMITS.RISK_REWARD_RATIO = ratio;
            
            logMessage(`Configuration: Ratio 1:${ratio.toFixed(1)} | SL ${sl}% / TP ${tp}%`, 'success');
            logMessage(`Mode: ${tradingMode} | Confiance IA: ${aiConfidence}%`, 'info');
        }

        // ================= INITIALISATION =================
        document.addEventListener('DOMContentLoaded', function() {
            loadConfig();
            updateExposure();
            
            document.getElementById('trade-amount').addEventListener('input', updateExposure);
            document.getElementById('margin-calc-amount').addEventListener('input', updateExposure);
            document.getElementById('trading-mode').addEventListener('change', updateUI);
            
            updateUI();
            logMessage('CryptoVision AI Futures 5.0 charg√©e - MODE 100% R√âEL', 'info');
            logMessage('üîß Mode: Connexion directe √† LBank API - Pas de simulation', 'warning');
            logMessage('üì° Tous les appels utilisent l\'API r√©elle LBank', 'info');
            logMessage('‚ö° Configuration: Levier 20√ó FIXE | Marge isol√©e OBLIGATOIRE', 'info');
            logMessage('ü§ñ IA experte auto-s√©lection: Analyse et choisit la meilleure paire', 'info');
            logMessage(`üéØ Ratio Risque/R√©compense: 1:${TRADING_LIMITS.RISK_REWARD_RATIO} (SL 5%/TP 15%)`, 'info');
        });
    </script>
</body>
</html>
